<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>ECSE211 Getting Started Guide</title>
  <meta name="author" content="">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="files/style.css" rel="stylesheet">
</head>

<body>


<div class="content">

<h1 id="ecse211-getting-started-guide">ECSE211 Getting Started Guide <a class="btt" href="index.html">[home]</a></h1>
<hr>

<div class="contents">
<h2 id="contents">Contents</h2>
<ul>
  <li><a href="#background">Background</a></li>
  <li><a href="#the-kit">Hardware - The Kit</a>
  <ul>
   <li><a href="#the-battery">The battery</a></li>
   <li><a href="#the-motors">The motors</a></li>
   <li><a href="#the-sensors">The sensors</a></li>
   <li><a href="#the-brick">The “Brick”</a></li>
   <li><a href="#defective-components">Defective Components</a></li>
  </ul>
  </li>
  <li><a href="#lejos">Software - LeJOS</a>
  <ul>
   <li><a href="#preparing-your-computer">Preparing your computer</a></li>
   <li><a href="#installing-lejos-to-the-sd-card">Installing leJOS to the SD card</a></li>
   <li><a href="#running-code-on-the-brick">Running code on the brick</a></li>
   <li><a href="#resetting-the-ev3">Resetting the EV3</a></li>
   <li><a href="#useful-information">Useful information</a></li>
  </ul>
  </li>
  

  <li><a href="#webots">Software - WeBots</a>
  <ul>
   <li><a href="#webots_preparingYourComputer">Preparing your computer</a></li>
   <li><a href="#webots_overview">Overview</a></li>
   <li><a href="#webots_designingARobot">Designing a Robot</a></li>
   <li><a href="webots_writingacontroller">Writing a controller</a></li>
  </ul>
  </li>
  
</ul>
</div>





<h2 id="background">Background <a class="btt" href="#">[top]</a></h2>
<hr>

<p>The primary objective of this course is to learn about the <strong>design process</strong>. In fulfillment of that objective, lectures will teach the basic theory while labs will allow you to get the necessary practical experience, which will come in the form of designing an autonomous robot using the <a href="https://education.lego.com/en-us/products/lego-mindstorms-education-ev3-core-set-/5003400">LEGO Mindstorms EV3 kit</a> embedded system.</p>

<p>The heart of Mindstorms is the LEGO “Brick”, which serves as a general purpose embedded controller with sensor inputs and motor outputs, operated by a simple user interface (UI) consisting of an LCD display and a set of push buttons. Think of the microcontroller in the “Brick” as a very basic computer with a small processor and a bit of memory, just enough to power a small robot.</p>

<p>A microcontroller becomes an embedded system when you program it with software; as such, a large part of building an embedded system involves designing, writing and testing software. Every embedded system will have a <em>development environment</em> that gives you the basic tools you need to actually write the software. In ECSE202, you wrote simple Java programs using the Eclipse Integrated Development Environment (IDE). For this course, we have kept things the same. As you’ve no doubt noticed, Java runs on a lot of different devices, from Windows to macOS and your Android phone. This is because all Java code runs on a JVM (Java Virtual Machine), which translates Java code into a form that the specific device actually understands. This ability is often  referred to as “write once, run everywhere.” The JRE (Java Runtime Environment) includes the JVM and code specific to a device.</p>

<p>In this course, you will run Java on the EV3 robot as leJOS provides the
JRE for the EV3. As part of the JRE, leJOS provides various classes that
allow you to use the robot’s motors, sensors and other components. These
classes take care of many of the complex details that usually come up in
robotics, allowing you to focus on building a robot and not, for
instance, getting a motor to turn in the right direction. A plugin for
Eclipse lets you write code on your computer and upload it to the leJOS
environment easily.</p>

<p>Unfortunately, the EV3 runs the Mindstorms operating system, which is
intended for people without programming experience (e.g. late elementary
to high school age) and doesn’t support Java, so we need to reconfigure
it by installing the leJOS software. As the Brick runs the Mindstorms
environment on top of Linux, all we need to do to install leJOS is to put
it on an SD card. We will discuss how to do this later.</p>

<h2 id="the-kit">Hardware - The kit <a class="btt" href="#">[top]</a></h2>
<hr>

<p>The kit we provide contains the “Brick” mentioned earlier, motors,
sensors and various LEGO parts.</p>

<h3 id="the-battery">The battery <a class="btt" href="#">[top]</a></h3>

<p>You will receive both AA batteries and a rechargeable battery pack,
shown in Fig. 1b. The brick can be powered by either, but we
recommend using the rechargeable battery in most cases. The battery can
be charged with the included wall adapter, either by itself or while
inserted into the brick. When both green and red LEDs are on, the
battery is charging. When only the green LED is on, the battery is fully
charged. Note that if the battery is in the brick while charging it may
not reach 100% until the EV3 is powered off. <strong>We recommend keeping the
battery plugged in as often as possible.</strong> In the leJOS software, you will
see the battery voltage displayed in the top left corner as shown in
Fig. 1a. The highest it can go is 8.0V; we recommend you
start charging it once it gets below 7.0V. Try to avoid letting the
battery die completely as this can damage it and reduce its charge
capacity.</p>

<figure>
<img style="width:40%" src="files/battery2.png">
<img style="width:40%" src="files/battery1.png">
<br>
<figcaption>Figure 1: (a) The main menu with a fully charged battery and (b) the battery itself.</figcaption>
</figure> 

  



<p><br></p>

<h3 id="the-motors">The motors <a class="btt" href="#">[top]</a></h3>

<p>There are three types of motors in your kit: medium (Fig. 2a), large 
EV3 (Fig. 2b) and large NXT (Fig. 2c). The large NXT motors are older 
than the
EV3 ones, but besides a difference in attachment points they are
identical. The main difference between the large and medium sizes is
power and precision: the large ones are powerful, but not the most
accurate. They are well suited for jobs like driving the entire robot
around. The medium one by contrast is weaker but much more precise; you
would use it for smaller jobs like moving a sensor back and forth. All
motors connect to the ports A - D on the top of the brick.</p>


<figure>
<img style="width:30%" src="files/motor-medium.png">
<img style="width:30%" src="files/motor-ev3.png">
<img style="width:30%" src="files/motor-nxt.png">
<br>
<figcaption>Figure 2: Three types of motors, from left to right: (a) EV3 Medium Motor, (b) EV3 Large Motor, (c) NXT Motor</figcaption>
</figure> 


<h3 id="the-sensors">The sensors <a class="btt" href="#">[top]</a></h3>

<p>While you receive several sensors, there are two that are used the most
in the course: the ultrasonic and color sensors. The ultrasonic sensor
(Fig. 3a) is used to measure distance by sending
ultrasonic waves and measuring how long it takes the wave to echo back.
Its main use is in detecting obstacles the robot needs to avoid.
Unfortunately, ultrasonic waves are not the best way to measure distance
and the sensor can easily fail to detect objects or detect objects that
aren’t there, which you will need to try and compensate for in software.
The color sensor (Fig. 3b), often referred to as a light sensor, can
determine the color of an object as well as the intensity of light
reflected by said object. This is useful for detecting the black lines
on the wooden panels your robots will drive on. In order to work
properly, the sensor needs to be placed at a very specific distance from
the object, which you will to determine. Other than that, it is much
more reliable than the ultrasonic sensor. All sensors connect to the
ports labelled 1 - 4 on the bottom of the brick.</p>

<figure>
<img style="width:30%" src="files/sensor-ultrasonic.png">
<img style="width:30%" src="files/sensor-color.png">
<br>
<figcaption>Figure 3: Useful sensors, from left to right: (a) Ultrasonic Sensor, (b) Color Sensor </figcaption>
</figure> 



<h3 id="the-brick">The “Brick” <a class="btt" href="#">[top]</a></h3>

<p>The “Brick” you receive, shown in Fig. 4, is an embedded system as described in the <a href="#background">background</a> section. The important features are as follows:</p>

<figure>
<img style="width:40%" src="files/ev3.png"><br>
<figcaption>Figure 4: The LEGO “brick”. </figcaption>
</figure> 

<ul>
  <li>
    <p><strong>LCD</strong>: Used to display information.</p>
  </li>
  <li>
    <p><strong>Speaker</strong>: Can make beeps, useful in some labs to let you know
what your code is doing. Also capable of playing the <em>Imperial
March</em> from Star Wars.</p>
  </li>
  <li>
    <p><strong>SD Card slot</strong>: For the SD card on which leJOS is installed.</p>
  </li>
  <li>
    <p><strong>USB type-A</strong>: Used for the USB Wi-Fi adapter.</p>
  </li>
  <li>
    <p><strong>USB mini-B</strong>: Used for connecting to a computer.</p>
  </li>
  <li>
    <p><strong>Ports A-D</strong>: Compatible with the RJ-11 like wires you are provided
for connecting motors.</p>
  </li>
  <li>
    <p><strong>Ports 1-4</strong>: Same as the motor ports, except used for the various
sensors.</p>
  </li>
</ul>

<p>The brick can be turned on by pressing the center button for a second or
two. In leJOS, it can be turned off by pressing the back (a.k.a. escape)
button (top left) and confirming the shutdown command.</p>

<h3 id="defective-components">Defective components <a class="btt" href="#">[top]</a></h3>

<p>On rare occasions, one of your parts may be defective. If you believe
this to be the case, show the problem to a TA in the lab to verify
before exchanging the part for a new one at the counter where you
originally picked up your kit.</p>


<h2 id="lejos">Software - LeJOS <a class="btt" href="#">[top]</a></h2>
<hr>

<h3 id="preparing-your-computer">Preparing your computer <a class="btt" href="#">[top]</a></h3>

<p>In order to work with the EV3, you need to set up your <em>development
environment</em> as mentioned in the <a href="#background">background</a> section.</p>

<ol>
  <li>
    <p>Download the file <code>leJOS_0.9.1_Package.zip</code> from MyCourses and
extract the contents. The directory structure should look like this:</p>

    <ul>
      <li>Computer</li>
      <li>Documentation</li>
      <li>SD_Card</li>
      <li><code>ecse211-eclipse-preferences.epf</code></li>
    </ul>
  </li>
  <li>
    <p>Copy the <code>leJOS_EV3_0.9.1-beta</code> folder
found within the <code>Computer</code> folder to a location on your machine. Keep track of this location.</p>
  </li>
  <li>
    <p>Install and setup Eclipse <strong>exactly</strong> as described here.</p>

    <p><strong>Note:</strong> Many students have asked if they could use a previous Eclipse installation. The answer is <strong>no</strong>, because we do not want you to have Eclipse settings from a previous course/project. 
We also do not want our custom settings from (c) to interfere with your other courses/projects.</p>

    <p>a) Follow <a href="https://www.eclipse.org/downloads/packages/installer">these instructions</a>. The
installer will ask you what version to install. “Eclipse IDE for
Java EE (Enterprise) Developers” is sufficient for this course. Note that you will 
need to install Java 8 or above (if you haven’t already) to run Eclipse.</p>

    <p>b) When starting Eclipse for the first time, select (or create) a workspace folder that is dedicated for this course,
so your other projects can have their own settings. Keep track of this 
folder for step c below.</p>

    <p>c) Configure Eclipse settings according to our requirements. Open Eclipse Preferences 
and select Import (the button in the lower-left corner of the window with this arrow ↘), then choose 
<code>ecse211-eclipse-preferences.epf</code>, which can be found in the zip file you downloaded
from MyCourses. Select all the boxes.</p>

    <p>d) <strong>Strongly recommended:</strong> Use the Eclipse dark theme to better distinguish source code elements (eg, variables, methods).
If it is not already set, open Eclipse Preferences and select <code>General</code> (double-click) <code>→ Appearance → Theme → Dark → Apply and Close</code>. Restart Eclipse to fully apply the dark theme.</p>
  </li>
  <li>
    <p>Install the Eclipse plugin. Open
Eclipse, and navigate to <code>Help → Install New Software...</code>.
Paste this link in the Work with… textbox: <code>http://lejos.sourceforge.net/tools/eclipse/plugin/ev3</code>.
Then select Add… and enter <code>LeJOS EV3 Eclipse plugin</code> as a repository name. Check the “leJOS EV3 Support” box and follow the prompts.</p>

    <p>Select <code>Install anyway</code>
when the warning about unsigned content appears. After installation,
you need to tell the plugin where you installed leJOS as well as how
to connect to your brick. The plugin settings page is called
<code>leJOS EV3</code> and is part of the Eclipse “Preferences” window.
Fig. 5 shows an example of how to set it up on a
Linux system. Set it up as follows:</p>

    <ul>
      <li>
        <p>Make sure <code>EV3_HOME</code> is set properly to wherever you installed
leJOS. This is the folder inside <code>Computer</code>.</p>
      </li>
      <li>
        <p>The box “Run Tools in separate JVM” should be checked</p>
      </li>
      <li>
        <p>Make sure “Use ssh and scp” is <em>not</em> checked</p>
      </li>
      <li>
        <p>You will set the IP address after setting up LeJOS on the EV3, so ignore this for now.</p>
      </li>
    </ul>
  </li>
</ol>

<figure>
<img style="width:60%" src="files/ev3_settings.png"><br>
<figcaption>Figure 5: The EV3 settings.</figcaption>
</figure> 

<h3 id="installing-lejos-to-the-sd-card">Installing leJOS to the SD card <a class="btt" href="#">[top]</a></h3>

<p>The next step is to install leJOS onto the SD card.  Please note, The SD card you receive may already have leJOS on it, but it is often in some broken state after being used for an entire semester so it needs to be replaced. The SD cards provided to you are often corrupt and are not reliable, so we recommend purchasing your own microSD card (which you can keep!), with a capacity that <strong>does not exceed 16GB</strong>.</p>

<p><strong>If you have problems, post in the discussion board or ask a classmate for assistance.</strong></p>

<ol>
  <li>
    <p>Insert the SD card into a card reader connected to (or part of) your
computer.</p>
  </li>
  <li>
    <p>Format the entire SD card as follows:</p>

    <ul>
      <li>
        <p><strong>Partition table</strong>: MS-DOS</p>
      </li>
      <li>
        <p><strong>Partition layout</strong>: a single FAT32 partition occupying
the entire SD card, i.e. 16GB or 14 GiB</p>
      </li>
    </ul>

    <p>Your OS should have a tool that can do this.
 Alternatively, there are many third party tools that can do it
 for you. Feel free to look at the many good guides for SD
 card formatting online if you have trouble. Be careful to
 select the correct device, as otherwise you could end up
 <em>wiping out your operating system</em>.</p>

    <p><strong>Note:</strong> You will need to delete all partitions from the SD card to
 perform this step successfully. To do that in Linux, use a tool like
 <code>gparted</code>. In Windows, use <code>Computer Management</code> (eg, in the image
 below, delete partitions <code>D:</code> and <code>E:</code> under Disk 10).</p>

<figure>
<img style="width:75%" src="files/comp_mgmt.png"><br>
<figcaption>Figure 6: Partition layout.</figcaption>
</figure> 
 

  </li>
  <li>
    <p>Copy all files from the folder <code>SD_Card</code> to the
SD card.</p>
  </li>
  <li>
    <p>Safely eject the card using the appropriate method for your
operating system.</p>
  </li>
  <li>
    <p>Insert the card into the SD card slot on the brick, making sure the
brick is powered off.</p>
  </li>
  <li>
    <p>Turn the brick on (center button) and wait for leJOS to go through the installation
procedure, which will take about 10 minutes.</p>
  </li>
  <li>
    <p>When it’s done, you should see the screen as shown in Fig. 7.</p>
  </li>
</ol>

<figure>
<img style="width:35%" src="files/battery2.png"><br>
<figcaption>Figure 7: The EV3 screen after leJOS installs.</figcaption>
</figure> 

<h3 id="running-code-on-the-brick">Running code on the brick <a class="btt" href="#">[top]</a></h3>

<p>Now that leJOS is installed, the next step is to get some code running
on the brick. To do this, we need to establish a connection between your
computer and the brick. There are three different ways to do this: USB,
Bluetooth or WiFi. As all of them use the Internet Protocol, any
software that works with one will work with the others as long as the
settings are correct. Since you will need Wi-Fi for debugging starting in Lab 2,
we will explain how to set it up here.</p>

<ol>
  <li>
    <p>With the brick turned off, insert the Wi-Fi adapter.
Then turn the brick on and connect to the DPM Wi-Fi 
network using the Wi-Fi menu. The password is <strong>dddpppmmm</strong>. Connect your computer 
to the same network. Note that you will lose internet access. An alternative is to
use a personal hotspot.</p>
  </li>
  <li>
    <p>In Eclipse Preferences → leJOS EV3, check and fill the “Connect to named brick”
field with the IP address shown on the third line of the EV3 LCD. It should be in 
the 192.168.2.x range.</p>

    <p><strong>Note:</strong> Every time you switch on the brick, check whether its IP address has changed.
If so, update the above setting.</p>
  </li>
  <li>
    <p>Create a new Eclipse project as follows:</p>

    <ol>
      <li>
        <p>Open Eclipse and navigate to
<code>File → New → Project...</code></p>
      </li>
      <li>
        <p>Select <code>leJOS EV3 Project</code></p>
      </li>
      <li>
        <p>Name it <code>HelloWorld</code> and select <code>JavaSE-1.7</code> for
<code>Use an execution environment JRE</code>.  If you do not specify <code>JavaSE-1.7</code>, your code will crash immediately when you run it on the brick. Click <code>Finish</code>. An example of the page is shown in Fig. 8.</p>
      </li>
      <li>
        <p>Create a new class named <code>HelloWorld</code> in the package
<code>ca.mcgill.ecse211.project</code>.</p>
      </li>
    </ol>
    
<figure>
<img style="width:45%" src="files/new_project_settings.png"><br>
<figcaption>Figure 8: Creating a new EV3 project.</figcaption>
</figure> 


    <ol>
      <li>
        <p>Add some code so that your program prints to the LCD and waits for a button to be pressed to exit.  If you don’t wait for a button press the program will exit immediately and you will end up looking at the leJOS menu rather than the text specified in your code. Listing 1 provides an example.</p>

<figure class="code">
  <pre>
package ca.mcgill.ecse211.helloworld;

import lejos.hardware.Button;

/**
 * HelloWorld example: prints to screen and waits for button press.
 */
public class HelloWorld {

    public static void main(String[] args) {
        System.out.println("Hello World!");
        Button.waitForAnyPress();
    }

}
  </pre>
  <figcaption>Listing 1: HelloWorld example code.</figcaption>
</figure>

      </li>
      <li>
        <p>Run the project, selecting the <code>leJOS EV3 Program</code> option.
This tells Eclipse that it needs to
run your code on the EV3 and not your laptop.</p>
      </li>
      <li>
        <p>Assuming the Eclipse plugin is set up as in step 5 of <a href="#preparing-your-computer">Section 3</a>, the code should be compiled and
uploaded to the brick.</p>
      </li>
      <li>
        <p>Verify that the LCD shows “Hello World!” and exit the program by
pressing any button on the EV3.</p>
      </li>
    </ol>
  </li>
</ol>

<p>Note that the desktop computers in the lab only support USB. To set 
that up, plug in the brick to the computer with the provided USB cable 
and check the network settings. There should be a new interface with an 
IP address in the
<code>10.0.1.x</code> range in addition to the normal Ethernet
connection. If you either don’t see a new interface or it does not
have an IP address in the correct range, the computer cannot see
the EV3. This is likely a driver, USB port or firewall issue.</p>

<h3 id="resetting-the-ev3">Resetting the EV3 <a class="btt" href="#">[top]</a></h3>

<p>Over the course of the semester, you may at some point need to reset 
the EV3 brick.
The cause might be anything from an infinite loop in your code that 
doesn’t let you quit to a bug in leJOS. Whatever the cause, we present 
several ways of resetting the robot if you
can’t get it to respond. We recommend trying them in the order 
presented, so the last
step should only be done if all else fails.</p>
<ol>
  <li><strong>Soft Reset:</strong> Hold the middle and down buttons simultaneously. Your program should
exit and return to the main menu.</li>
  <li><strong>Stop Program:</strong> Using the EV3 control panel (see below), connect to your robot and click on the button named Stop Program.</li>
  <li><strong>Hard Reset:</strong> Hold the middle and back buttons simultaneously until the robot starts rebooting.</li>
  <li><strong>Remove battery:</strong> The last way of resetting the brick is to simply remove and reinsert the battery.</li>
</ol>

<p>The last two steps don’t allow leJOS to shutdown nicely, and can 
cause the SD card to get corrupted. If you experience weird behaviour 
after trying one of the last two steps, you
may need to reformat your SD card and re-install leJOS.</p>

<h3 id="useful-information">Useful information <a class="btt" href="#">[top]</a></h3>

<p>While the above discusses all the essentials, there are several points
that aren’t essential for the first lab but can come in handy later:</p>

<ol>
  <li>
    <p>When the EV3 is connected to your laptop, you can control it and get
data from it. Open Eclipse and navigate to
<code>leJOS EV3 → Start EV3Control</code>. Click <code>Search</code>, wait for it
to find your robot, and click <code>Connect</code>.  If your robot doesn’t appear, it either isn’t connected to your laptop or it is being blocked by a firewall, as is the case for the desktop computers in the lab.  There are many useful options available to you, ranging from testing motors and sensors to
running code or killing a running program. Of particular importance is the <code>Console</code> tab, which shows what’s displayed on the LCD and the output of your program. This means that you can use <code>System.out.println()</code> in your code and have the output on your laptop rather than the small LCD, useful when you need to examine a lot of data (eg, in CSV format). Fig. 9 shows what the console looks like when running the <code>HelloWorld</code> program. Feel free to explore the other tabs as well.</p>

<figure>
<a href="files/ev3_control.png"><img style="width:70%" src="files/ev3_control.png"></a><br>
<figcaption>Figure 9: The EV3 control panel.</figcaption>
</figure> 

  </li>
  <li>
    <p>It is possible to run your code on the EV3 with the Java debugger as
long as the EV3 is connected. The process is exactly the same as
debugging on your computer, except for the fact that you have to
choose <code>Debug As → LeJOS EV3 Program</code> instead of
<code>Java Application</code>.</p>
  </li>
  <li>
    <p>An alternative to Wi-Fi or USB is Bluetooth, although it has limited range. 
Once you’ve paired the EV3 with your laptop, you can upload code and use the 
EV3 control panel as you would over Wi-Fi. It may take a while after pairing for 
your laptop to properly connect to the EV3, though, so you will need to be patient.</p>
  </li>
  <li>
    <p>You can change the EV3’s name via the LCD
(<code>System → Change name</code>). This can be useful if you don’t know which robot is yours.</p>
  </li>
  <li>
    <p>Documentation for all leJOS functions can be found in the
<code>Documentation</code> folder in the zip file mentioned in step 1 of <a href="#preparing-your-computer">Section 3</a>. Simply open the <code>index.html</code> file
within using your favorite browser; the documentation follows the
standard Javadoc format. Keep in mind that the documentation covers
all of leJOS, including support for older LEGO products like the NXT
and RCX so make sure you’re looking at the correct section.</p>
  </li>
</ol>



<h2 id="webots">Software - Webots <a class="btt" href="#">[top]</a></h2>
<hr>
<p>Webots is a robot simulation framework that we will use to work with virtual robots.</p>

<p><emph>Please note that a lot of the complexity of Webots is abstracted away with the proto files that we provide, but feel free to look at the implementation of the proto files or create your own.  We cover here the minimum amount of information needed to complete the course, but Webots is a fun tool to play with.</emph></p>



<h3 id="webots_preparingYourComputer">Preparing your computer <a class="btt" href="#">[top]</a></h3>
  To use this Webots, the following software needs to be installed to your computer:
<ul>
 <li><a href="https://cyberbotics.com/"><b>Webots:</b></a><br>Webots is the robot simulation package itself. The installation files can be found on MyCourses.  Note: please use the MyCourses version to ensure the same version is used by everyone.</li>
 <li><a href="https://www.leocad.org/"><b>LeoCad:</b></a><br>LeoCAD is a computer aided design software used to build virtual LEGO assemblies.  It will be used to design the physical appearance of your robots.</li>
 <li><a href="https://www.oracle.com/java/technologies/javase-downloads.html"><b>Java Development Kit (JDK):</b></a><br>As the robot controllers will be developped in Java, the Java Development Kit is required to compile the code.  Webots requires the 64 bits version of the JDK, with a version of 1.8 or higher.</li>
</ul>

<h4>Linux</h4>
<p>The Linux version of Webots only needs to be extracted and the executable is in the main folder, no installation required.  Depending on your Linux distribution, both LeoCAD and the JDK should be available through your package manager.</p>
<h4>Windows & Mac</h4>
<p>All of the applications should be installed normally.</p>
  
  
<h3 id="webots_overview">Webots Overview <a class="btt" href="#">[top]</a></h3>
<p>Before we start simulating our own robots, let's look at how Webots works and how to use it.  To do so, we will use one of the example files provided with Webots.</p>

<p>Start Webots, and open the sample by going <code>File → Open Sample World...</code>, then navigate through the list to find <code>samples → devices → bumper</code>.  Once loaded, your window should look similar to the screenshot in Figure 10.  We will now describe the purpose of the main panels and menus of the Webots environment.</p>

<figure>
<a href="files/webots-mainwindow.png"><img style="width:80%" src="files/webots-mainwindow.png"></a><br>
<figcaption>Figure 10: Webots main window</figcaption>
</figure> 

<h4>Toolbar</h4>
<p>At the top of the screen is the main toolbar which contains icons for commonly used functions.  Some of those icons should be </p>
<ul>
 <li><img src="files/webots-icon-hide.png">: Hide or show the scene tree.</li>
 <li><img src="files/webots-icon-plus.png">: Add nodes to the scene tree.</li>
 <li><img src="files/webots-icon-resetview.png">: Reset the viewpoint.</li>
 <li><img src="files/webots-icon-reload.png">: Reload the simulation</li>
 <li><img src="files/webots-icon-play.png">: Start the simulation, will turn into a pause icon to pause the simulation and vice-versa.  You can click this button if the simulation is not already running to start the simulation and see the robot move.</li>
</ul>
<p>It is strongly suggested not to use the fast-forward buttons as it can cause the simulation to fail.</p>


<h4>3D View</h4>
<p>The 3D view is the main part of the window and is where you see the robot and its environment.  You can change the position of the camera (move around) with the following default controls:</p>

<ul>
 <li>Pan: Right click and drag</li>
 <li>Tilt: Left click and drag</li>
 <li>Zoom: Scroll-wheel</li>
</ul>

<h4>Console</h4>
At the bottom of the window is the console.  Both Webots and your controller can print information here. ie, when you use <code>System.out.println(...)</code>, it will be printed to this console.

<h4>Text Editor</h4>
On the right side of the window is the text editor, where you will write your programs.  It is useful to maximize, or undock this panel when writing code to get more screen space.  

<h4>Scene Tree</h4>
<p>The panel in the left column is the "Scene Tree", where the world and all objects within it are defined.  Each element in the list is a node, which can be expanded by double-clicking on it, or using the small arrow beside it.  Expanding a node will present the parameters of the node and possibly children nodes.</p>

<p>The first two elements of the scene tree are always the <code>WorldInfo</code> and the <code>Viewpoint</code>.  These cannot be removed from the tree.  The <code>WorldInfo</code> contains global parameters that affect everything in the world, ie, gravity.  The <code>Viewpoint</code> node controls the parameters of the virtual camera that lets you see the simulation in the "3D View" panel.</p>

<p>All of the other nodes define the contents of the virtual world.  Their order is not strictly important, <small>unless references are used between objects, in which case the node being referenced needs to appear before the node containing the reference</small>.  Looking at the sample, the next two nodes are the <code>TexturedBackground</code> and the <code>TexturedBackgroundLight</code> nodes.  These two nodes work together to create a "skybox" around our world and create some general lighting.  Without these two nodes, the image would be black.</p>

<p>The next node is the <code>RectangleArena</code>.  This is a proto node, that is, this node is a self-contained mini scene tree that contains other objects.  The <code>RectangleArena</code> creates the floor and the walls, but instead of defining the parameters of each object separately, the proto node has simple parameters such as <code>floorSize</code> and <code>floorTileSize</code> that control the underlying objects.</p>

<p>The next four nodes are the four colored solid boxes within the arena.  These are solid nodes.  Solid nodes are a base type of nodes that define solid objects.  Expanding one of these nodes presents its parameters.  The important ones here are:</p>

<ul>
 <li><code>translation:</code> the position of the solid in the world, in Cartesian coordinates.</li>
 <li><code>rotation:</code> the rotation of the solid in the world.  The notation here is similar to quaternion notation, where he rotation is defined as an angle in radian and an axis.  For example, setting x=1, y=0, z=0, and angle=1.57 means a 90 degrees rotation around the x axis.  This might seem a little unintuitive at first, but it's a common and useful notation for 3D geometry.</li>
 <li><code>children:</code> this parameter is a subtree that can contain one or more nodes.  In the case of the boxes in the sample, it contains only one children node of type <code>shape</code>.  A shape node is a 3D model that has both a geometry and an appearance component.  Webots has different base solids predefined for the geometry, such as the <code>box</code> used in the sample.</li>
 <li><code>boundingObject:</code> The bounding object defines the shape used by the simulator for the collision detection.  It contains a single sub-node of type <code>shape</code>.  In the case of the sample file, a reference to the shape node that defines the appearance of the box is used for the bounding box as both are the same.  However, in most cases, the bounding box contains a simplified model of the object as complex geometry can cause issues or slow down the simulator.</li>
 <li><code>physics:</code> the physics parameter can hold a <code>physics</code> node, which defines the mass, center of mass, and other parameters of the solid.  In the case of the obstacle blocks in the sample file, the physics parameter is set to NULL, so the simulator will not simulate these objects (they are stationary).</li>
</ul>

<p>The last node is of type <code>Robot</code>.  This is a node similar to the <code>solid</code> node, but has more parameters, most notably, the <code>controller</code> parameter which allows you to choose the the program that will control the robot.  You can explore the children of the robot node to see more type of nodes available in Webots, including the <code>transform</code> and <code>hingeJoint</code> nodes.  We will discuss these types of nodes in more details when we design our robot.</p>

<h4>Project Folder Structure</h4>
<p>The project folder contains at a minimum the following subfolders:</p>
<ul>
<li><strong>controllers: </strong> contains the robot controller programs, each in their respective subfolder.</li>
<li><strong>protos: </strong> contains proto files (.proto).  These files are sub-trees that can be inserted into the world scene tree as a single node.</li>
<li><strong>worlds: </strong> contains world definition files (.wbt), which are the textual definition of the scene tree.</li>
</ul>


<hr>
<h3 id="webots_designingARobot">Designing a Robot <a class="btt" href="#">[top]</a></h3>
<h4>Modeling the robot</h4>
<p>The first step in simulating a robot is to prepare its digital model.  To do so, open LeoCAD and you will get a window similar to the screenshot shown in Figure 11.</p>

<figure>
<a href="files/leocad-main.png"><img style="width:70%" src="files/leocad-main.png"></a><br>
<figcaption>Figure 11: The main LeoCAD window.</figcaption>
</figure> 

There are 5 main panels in LeoCAD, the first is a 3D rendering of your model.  You can interact with this view using the following default controls:

<ul>
 <li>Pan: Right click and drag while holding the shift key</li>
 <li>Tilt: Right click and drag</li>
 <li>Zoom: Scroll-wheel</li>
</ul>

The other 4 panels are:
<ul>
 <li>Parts: This allows you to select a parts list and select individual parts.  You can drag parts to the 3D view to add them to your model.</li>
 <li>Colors: This is where you select the color of a part, before adding it to your model.  The color can be changed after being placed by editing the part properties.</li>
 <li>Properties: The properties tab provides control over the parameters of the selected part.  This is useful to adjust the position of a part more precisely than moving it in the 3D world with the mouse.</li>
 <li>Timeline: This is used to create stop motion animations, we will not need this.</li>
</ul>

<p>It is now time to design a robot by selecting the parts and dragging them to our model.  Note: for the purpose of simulation, it is not required or desired to add every single peg between parts.  Adding these increases the number of triangles that will need to be rendered by the simulator and can slow down the overall simulator, depending on your system.  Note: the wheels that come with kit, and those you should use, are called <strong>"Wheel Rim 20 x 30, 6 Spokes, Ribs with Tyre 43.2 x 26 Balloon Small"</strong> in LeoCAD.  These wheels have a radius of exactly 21.465 cm 😉.  The part defined in the simulator is defined with a value of 21 cm to both keep use a simple round number and to simulate the tires deforming a little bit under the weight of the robot 😉 😉.</p>

<p>Once you are done designing your robot, you should have a complete 3D model of your robot.  An example design is given <a href="files/robot.ldr">here</a> and shown in Figure 12.</p>

<figure>
<a href="files/leocad-sample.png"><img style="width:70%" src="files/leocad-sample.png"></a><br>
<figcaption>Figure 12: Sample robot.</figcaption>
</figure> 

<p>At this point, this design is a static 3D model.  It contains no information about which parts are motors or what their rotation axis are.  Similarly, the sensors are nothing more than empty shells.  To use this 3D model in the simulator and have the parts behave as they should, we need to split the model into its component sub-assemblies.  Anything connected to the main controller is the base assembly, and anything connected to the rotating part of a motor is a sub-assembly.  Each of these assemblies will need to be exported individually from LeoCAD.</p>

<p>For the robot shown in Figure 11, the main assembly is shown in Figure 13.  The wheels were removed as they rotate around the axis of the bottom motors, the ultrasonic sensor and its few mounting parts are also removed because they rotate on the top motor.  Not visible in Figure 13 is that the ball caster in the back of the  robot has also been removed as the ball is itself a sub-assembly as it needs to rotate, more on this later.</p>

<figure>
<a href="files/leocad-mainassembly.png"><img style="width:70%" src="files/leocad-mainassembly.png"></a><br>
<figcaption>Figure 13: Sample robot main assembly.</figcaption>
</figure> 

<p>The other two sub-assemblies are shown in Figure 14.</p>

<figure>
<a href="files/leocad-sensorassembly.png"><img style="width:40%" src="files/leocad-sensorassembly.png"></a>
<a href="files/leocad-wheelassembly.png"><img style="width:40%" src="files/leocad-wheelassembly.png"></a><br>
<figcaption>Figure 14: Sample robot sub assemblies.</figcaption>
</figure> 

<p>For simplicity, we provide you with some of the parts predefined in the simulator.  The following parts have been defined for convenience:</p>

<ul>
 <li>Controller: The EV3 controller</li>
 <li>Motors: All three types of motors (NXT, Large EV3, and Medium EV3)</li>
 <li>Sensors: The Ultrasonic and Color Sensors</li>
 <li>Wheels: The wheels that come with kit, the ball-caster, and the old caster are defined.</li>
</ul>

<p>For this reason, these parts can be removed from the assemblies and we end up with two models that need to be exported from LeoCAD.  Figure 15 shows what these two look like for the sample robot presented in Figure 11.</p>

<figure>
<a href="files/leocad-mainassembly-export.png"><img style="width:55%" src="files/leocad-mainassembly-export.png"></a>
<a href="files/leocad-sensorassembly-export.png"><img style="width:35%" src="files/leocad-sensorassembly-export.png"></a><br>
<figcaption>Figure 15: Sub-assemblies that need to be exported from LeoCAD for the sample robot.</figcaption>
</figure> 

<p>Save all of the sub-assemblies as separate <code>.ldr</code> files as you will need to convert them to the format used by the simulator in the next part.  The sample robot is pretty basic, so it only has 2 sub-assemblies, but larger and more complicated robots might have more moving parts.  For convenience, here are the two sub-assembly files for the sample robot:</p>

<ul>
 <li><a href="files/robot-base.ldr">Base Assembly</a></li>
 <li><a href="files/robot-ultrasonicsensormount.ldr">Sensor Assembly</a></li>
</ul>

<h4>Converting the LeoCAD files for Webots</h4>
<p>As mentioned previously, LeoCAD only provides the visual appearance of the robot.  To simulate the robot, Webots needs more information about the parts.  It needs the bounding box to detect and handle collisions, the mass of the parts to compute acceleration, and it needs the physical appearance model, including the 3D model and the colors, to make everything look nice.  To convert the files and add some of that missing information, we provide you with a converter, available <a href="converter.html">here</a>.  On this page, you will be able to upload a <code>.ldr</code> file and obtain the converted files.  You will receive 3 files, packaged within a zip file.  Uploading a file called <code>filename.ldr</code>, you will receive a zip file called <code>filename.zip</code> containing the following three <code>.proto</code> files:

<ul>
 <li><code>filename-boundingbox.proto</code>: This contains a Box node of a size that contains your model.  We can use this as the bounding box for the simulator.</li>
 <li><code>filename-shape.proto</code>: This contains the Shape of your model 3D model with the appearance information.</li>
 <li><code>filename-solid.proto</code>: This contains a solid node that ties uses the shape, the bounding box, and adds mass information.  This is the file you will use most often in the simulator.  <emph>Note: the mass is an approximation based on the volume of your model and the density of the plastic used to make LEGO.</emph></li>
</ul>

<p>You should place those 3 <code>.proto</code> files in the <code>protos</code> sub-folder of your project folder.  Note: You can create subfolders in the <code>protos</code> folder to help classifying parts.</p>

<p>When adding proto files to your project, make sure to click <img src="files/webots-icon-reload.png"> so that webots can reload the new files or new versions of the files.</p>

<p>More information is available on the <a href="converter.html">converter page</a>.</p>


<h4>Defining the robot in the simulator</h4>

<p>Before defining the robot, open one of the provided world file.  For this example we will use the world file from the first lab.  Figure 16 shows what the world looks like.</p>

<figure>
<a href="files/webots-samplerobot1.png"><img style="width:75%" src="files/webots-samplerobot1.png"></a>
<figcaption>Figure 16: Lab 1 world file after being opened.</figcaption>
</figure> 

<p>The first step is to click the <img src="files/webots-icon-plus.png"> button to add a new node to the scene tree.  From the "Add a node" selection dialog, select <code>Basenodes → Robot</code> node type.  This will create the robot node, and you should see a coordinate system marker appear at the origin of the world, as shown in Figure 17.  You'll also see in the console that webots has started the "void" controller.  This is the default controller that does nothing.</p>

<figure>
<a href="files/webots-samplerobot2.png"><img style="width:75%" src="files/webots-samplerobot2.png"></a>
<figcaption>Figure 16: New robot node created.</figcaption>
</figure> 

<p>Now, expand the robot node and set the position so that the robot is somewhere above the arena.  Click on the children node and click the <img src="files/webots-icon-plus.png"> button to add a new sub-node.  Select <code>PROTO nodes (Current Project) → Mindstorm → EV3 (solid)</code> to insert an EV3 controller into the robot.  You should end up with something that looks like Figure 17.</p>

<figure>
<a href="files/webots-samplerobot3.png"><img style="width:75%" src="files/webots-samplerobot3.png"></a>
<figcaption>Figure 17: Robot position adjusted and an EV3 controller is added.</figcaption>
</figure> 

<p>The EV3 is not in the right orientation, to correct this, we can expand the EV3 node and set its rotation to "1 0 0 -1.57", a rotation of -90 degrees around the x axis.  This is something that will need to be done for most parts that are converted from LeoCAD as it uses a different coordinate system.  Figure 18 shows what you should now see.</p>

<figure>
<a href="files/webots-samplerobot4.png"><img style="width:75%" src="files/webots-samplerobot4.png"></a>
<figcaption>Figure 18: Rotation of the EV3 controller is corrected.</figcaption>
</figure> 

<p>We can now click on the children node of the robot and once again click the <img src="files/webots-icon-plus.png"> button.  This time we will add the base assembly of our robot by selecting <code>PROTO nodes (Current Project) → Robot → robot-base-solid (Solid)</code>. The name of the proto will not be the same, it will be the name of the ldr file you converted earlier, with the suffix "-solid".  As we did before, we need to set the rotation of the newly imported node to "1 0 0 -1.57". Figure 19 shows what you should now see.</p>

<figure>
<a href="files/webots-samplerobot6.png"><img style="width:75%" src="files/webots-samplerobot6.png"></a>
<figcaption>Figure 19: Addition of the base assembly.</figcaption>
</figure> 

<p>With the rotation fixed, we see that the part is still not in the correct location.  This is because each converted part from Leocad is recentered around its centroid.  To fix this we can edit the position attribute of the node.  For the sample robot, the translation needs to be (0,-0.014,-0.08).  The simplest way to move the parts to the correct positions and orientations is to select the node, a coordinate system with arrows on and around each axis should appear.  These arrows can be used to roughly move and rotate the part.  To get a more accurate position, click in the value box of one component (highlighted in Figure 20), type 0.001 and use the up and down arrow keys to move the parts by 0.001m (1mm) manually.  The arrow keys will change the last digit of the value by 1, so if you type 0.0001, each arrow key stroke would move the part by 0.1mm.</p>

<figure>
<a href="files/webots-samplerobot7.png"><img style="width:75%" src="files/webots-samplerobot7.png"></a>
<figcaption>Figure 20: Setting the position of the main assembly.</figcaption>
</figure> 

<p>We now want to add the motors.  Once again, click on the children node of the robot and click the <img src="files/webots-icon-plus.png"> button.  This time we will select <code>PROTO nodes (Current Project) → Mindstorm → EV3-LargeMotor (Solid)</code> for the EV3 large motors and <code>PROTO nodes (Current Project) → Mindstorm → NXT-Motor (Solid)</code> for the NXT motor.  As before, we will set the rotation and position so that each motor is in the correct location and orientation.  One important parameter of the motors is the "name".  Each motor needs a different name as this is the name you will use in your controller to distinguish between the motors.  We can also add the color sensor to the robot at this point by adding a <code>PROTO nodes (Current Project) → Mindstorm → EV3-ColorSensor (Solid)</code> node.  We can also add the ball caster at the back of the robot by inserting a <code>PROTO nodes (Current Project) → Mindstorm → BallCaster (Transform)</code> node and positioning it appropriately.  You should now have something like Figure 21.</p>

<figure>
<a href="files/webots-samplerobot9.png"><img style="width:75%" src="files/webots-samplerobot9.png"></a>
<figcaption>Figure 21: Adding the three motors and the color sensor.</figcaption>
</figure> 

<p>We can now add the parts that are attached to the motors.  We will start with the left wheel.  To do so, select and expand the motor node that corresponds to the left motor.  You'll see within the motor node that there is a children node.  Select this children node and click the <img src="files/webots-icon-plus.png"> button.  Select <code>PROTO nodes (Current Project) → Mindstorm → wheel (Solid)</code> node.  As you can see in Figure 22, the wheel is added at the end position of the motor, rather than at the center of the robot.  This is because the proto node applies the translation corresponding to the position of the shaft to its childen nodes.</p>

<figure>
<a href="files/webots-samplerobot10.png"><img style="width:75%" src="files/webots-samplerobot10.png"></a>
<figcaption>Figure 22: Adding the left wheel.</figcaption>
</figure> 

<p>As before, we can adjust the position and orientation of the wheel.  We can select the children node of the right motor and do the same thing to add the right wheel.  We can also do the same to add the mount for the ultrasonic sensor.</p>

<figure>
<a href="files/webots-samplerobot11.png"><img style="width:75%" src="files/webots-samplerobot11.png"></a>
<figcaption>Figure 23: Adding the right wheel and the ultrasonic mount.</figcaption>
</figure> 

<p>The last thing to do is to add the ultrasonic sensor itself.  Select the children node of the NXT motor and add a new node of type <code>PROTO nodes (Current Project) → Mindstorm → EV3-Ultrasonic (Solid)</code>.  Adjust its position we are almost done building the robot.</p>

<figure>
<a href="files/webots-samplerobot12.png"><img style="width:75%" src="files/webots-samplerobot12.png"></a>
<figcaption>Figure 24: Final robot assembly.</figcaption>
</figure> 

<p>The final step is to go back to the root of the robot node and select the physics parameter.  Click the <img src="files/webots-icon-plus.png"> button and select <code>Base nodes → Physics</code> expand it and set the mass to 1 and the density to -1.  The actual mass of the robot is the sum of the masses of its components, but it is preferable to not set the robot mass to 0 as it sometimes causes issues.  Do not set any boundingObject for the robot node itself as the individual bounding boxes of the component parts create the bounding object of the robot.  Finally, in the <code>physics</code> node, double click the <code>inertiaMatrix</code> property and insert an identity matrix, so that the mass of the robot is centered at its origin. to  At this point the robot is complete and ready to be simulated. Click the <img src="files/webots-icon-play.png"> button and you should see your robot fall down to the floor.  Congratulation, it's a robot 🤖.  <strong>Note that this robot is only provided as an example, it will not work for all labs.</strong>  Hint: you might not want the color sensor on the rotation axis 😉.</p>

<p>Selecting the robot node will show the bounding volume of the robot as a set of wire frame box around it.  As you can see, the bounding volume is a simplified approximation of the robot's shape, which is the union of all the bounding boxes of the robot's components.  The only parts that are more precisely modeled in the bounding volume are the wheels and the ball caster as those parts need to be more accurately simulated.</p>

<figure>
<a href="files/webots-samplerobot13.png"><img style="width:75%" src="files/webots-samplerobot13.png"></a>
<figcaption>Figure 25: Bounding volume of the sample robot.</figcaption>
</figure>


<h3>Transferring your robot</h3>

There is no easy way to move your robot from one lab to another from the graphical user interface.  Redefining the robot in each lab is a cumbersome, but functional solution.  If you want to directly transfer your robot to another lab, you should do the following:
<ol>
 <li>Right click the robot node and select <code>Export</code>.  Export the node to a <code>.wbo</code> file.</li>
 <li>Export the node to a <code>.wbo</code> file.</li>
 <li>Open the <code>.wbo</code> file and copy it's content.</li>
 <li>Navigate to the <code>worlds</code> subfolder of the project folder and open the <code>.wbt</code> corresponding to the world where you want to insert your robot.</li>
 <li>Paste the content from the <code>.wbo</code> file at the end of the <code>.wbt</code> file.</li>
 <li>Load (or reload) the world in WeBots and your robot should be in the new file.</li>
</ol>
<hr>


<h3 id="webots_writingacontroller">Writing a controller <a class="btt" href="#">[top]</a></h3>

<p>For the first few labs, you will be provided with skeleton code, so you will not need to create a controller from scratch.  To select which controller your robot should use, expand your robot node in the world scene tree and select the controller node.  In the selection pane, you can select a controller and click the Edit button to open the Webots built-in editor.  Once the controller is selected, it can compiled by clicking <code>Build → Build</code> in the main menu bar.</p>

<p>When you want to compile a new version of a controller, it is recommended to rebuild everything as some modifications may not be recompiled properly otherwise.  To do so, click <code>Build → Clean</code>, then <code>Build → Build</code> to rebuild the entire controller.</p>


<h3>Notable changes between the Lejos API and the simulated Lejos API</h3>

<h4>Sounds</h4>
<p>LeJOS assumes that there is a single speaker, which is true on the LEGO EV3.  However, there can be multiple speakers in the simulated world as some robots can have multiple devices, or multiple robots may be present.  The supplied proto file for the EV3 brick includes a speaker, you don't need to add anything else to your robot.  An <code>EV3Speaker</code> object named <code>Sound</code> should be created in your resources file to make your program aware of the speaker.  Due to the differences, not all LeJOS functions have been implemented in the wrapper.  The following three functions are implemented:</p>

<ul>
<li><code>Sound.beep();</code> This is equivalent to the LeJos function <code>Sound.beep();</code></li>
<li><code>Sound.playSample(String filename);</code> This is equivalent to the LeJos function <code>Sound.playSample(java.io.File file)</code> but with a filename as an argument instead of a <code>java.io.File</code>.  The files should be in wav format as other formats may not work on all platforms, and should be placed in your controller folder.</li>
<li><code>Sound.speak(String text);</code> This has no LeJOS equivalent.  This uses text to speech to convert a string into voice and plays the resulting sound.</li>
</ul>




<h4>SampleProvider</h4>
<p>The <a href="http://www.lejos.org/ev3/docs/lejos/robotics/SampleProvider.html">SampleProvider</a> class is not defined as the wrapper classes for the sensors implement both of the <code>SampleProvider</code> functions themselves (<code>fetchSample</code> and <code>sampleSize</code>).  Instead of returning a SampleProvider, sensor functions such as <code>EV3UltrasonicSensor.getRGBMode()</code> return an object of their own type (usually a copy of themselves), set to the desired mode.  For example, the following LeJOS code to read the RGB value from a color sensor:</p>

<pre class="code">
[...]
SampleProvider RGBSensor = Resources.colorSensor.getRGBMode();
[...]
RGBSensor.fetchSample(buffer, 0);
[...]
</pre>

<p>Should be replaced by:</p>

<pre class="code">
[...]
Resources.colorSensor.getRGBMode().fetchSample(buffer, 0);
[...]
</pre>

<p>Which works on both the simulator and LeJOS on the real brick, without requiring an intermediate <code>SampleProvider</code> object.  Note that the <code>.getRGBMode()</code> is important to select what type of data to read from the sensor.  Similarly, the following code to read a value from an ultrasonic sensor:</p>

<pre class="code">
[...]
SampleProvider ultrasonic = Resources.usSensor.getDistanceMode();
[...]
ultrasonic.fetchSample(usData, 0);
[...]
</pre>

<p>Should be replaced by:</p>

<pre class="code">
Resources.usSensor.getDistanceMode().fetchSample(usData, 0);
</pre>



<h4>Ultrasonic Sensor</h4>
<p>The simulated ultrasonic sensor does not have a "listen" mode as the simulator does not support this.</p>





<p style="font-size:0.8em">© Instructor and Teaching Assistant generated course materials (e.g., handouts, notes, summaries, assignments, exam questions, etc.) are protected by law and may not be copied or distributed in any form or in any medium without explicit permission of the instructor. Note that infringements of copyright can be subject to follow up by the University under the Code of Student Conduct and Disciplinary Procedures.</p>
</div>

</body>
</html>
