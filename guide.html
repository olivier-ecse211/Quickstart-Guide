
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>ECSE211 Getting Started Guide</title>
  <meta name="author" content="">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="files/style.css" rel="stylesheet">
</head>

<body>


<div class="content">

<h1 id="ecse211-getting-started-guide">ECSE211 Getting Started Guide <a class="btt" href="index.html">[home]</a></h1>
<hr>

<div class="contents">
<h2 id="contents">Contents</h2>
<ul>
  <li><a href="#background">Background</a></li>
  <li><a href="#the-kit">Simulated Hardware</a>
  <ul>
   <li><a href="#the-battery">The battery</a></li>
   <li><a href="#the-motors">The motors</a></li>
   <li><a href="#the-sensors">The sensors</a></li>
   <li><a href="#the-brick">The “Brick”</a></li>
  </ul>
  </li>

  <li><a href="#webots">Software - WeBots and simlejos</a>
  <ul>
   <li><a href="#webots_preparingYourComputer">Preparing your computer</a></li>
   <li><a href="#webots_overview">Overview</a></li>
   <li><a href="#webots_designingARobot">Designing a Robot</a></li>
   <li><a href="#webots_writingacontroller">Writing a controller</a></li>
  </ul>
  </li>

</ul>
</div>

<p><strong>Please read this entire document before starting!</strong></p>

<h2 id="background">Background <a class="btt" href="#">[top]</a></h2>
<hr>

<p>The primary objective of this course is to learn about the <strong>design process</strong>.
The lectures will teach the basic theory while labs will allow
you to get the necessary practical experience, which will come in the form of designing an
autonomous robot using a simulated <a
href="https://education.lego.com/en-us/products/lego-mindstorms-education-ev3-core-set-/5003400"
>LEGO Mindstorms EV3 kit</a> embedded system.</p>

<p>The heart of Mindstorms is the LEGO “Brick,” which serves as a general purpose embedded
controller with sensor inputs and motor outputs. Think of the microcontroller in
the “Brick” as a very basic computer with a small processor and a bit of memory, just
enough to power a small robot.</p>

<p>A microcontroller becomes an embedded system when you program it with software; as such,
a large part of building an embedded system involves designing, writing and testing software.
Every embedded system will have a <em>development environment</em>. In ECSE202, you wrote
simple Java programs
using the Eclipse Integrated Development Environment (IDE). For this course, we have kept
things the same. As you’ve no doubt noticed, Java runs on a lot of different devices, from
Windows to macOS and your Android phone. This is because all Java code runs on a JVM (Java
Virtual Machine), which translates Java code into a form that the specific device actually
understands. This ability is often referred to as “write once, run everywhere.” The JRE
(Java Runtime Environment) includes the JVM and code specific to a device.</p>

<p>In this course, you will run Java on the simulated EV3 robot.
Simlejos provides various classes that allow you to use the robot’s motors, sensors
and other components. These
classes take care of many of the complex details that usually come up in
robotics, allowing you to focus on building a robot and not, for
instance, getting a motor to turn in the right direction.</p>

<h2 id="the-kit">Simulated Hardware<a class="btt" href="#">[top]</a></h2>
<hr>

<p>The simulated hardware includes the “Brick” mentioned earlier, motors,
sensors and various LEGO parts.</p>

<h3 id="the-battery">The battery <a class="btt" href="#">[top]</a></h3>

<p>Your simulated robot will contain a battery that must not be depleted.
We will provide more information on this later.</p>

<figure>
<img style="width:40%" src="files/battery1.png">
<br>
<figcaption>Figure 1: The battery</figcaption>
</figure> 

  



<p><br></p>

<h3 id="the-motors">The motors <a class="btt" href="#">[top]</a></h3>

<p>There are three types of motors that you can use: medium (Fig. 2a), large 
EV3 (Fig. 2b) and large NXT (Fig. 2c). The main difference between the large
and medium sizes is
power and precision: the large ones are powerful, but not the most
accurate. They are well suited for jobs like driving the entire robot
around. The medium one by contrast is weaker but much more precise; you
would use it for smaller jobs like moving a sensor back and forth. All
motors connect to the ports A - D on the top of the brick.</p>


<figure>
<img style="width:30%" src="files/motor-medium.png">
<img style="width:30%" src="files/motor-ev3.png">
<img style="width:30%" src="files/motor-nxt.png">
<br>
<figcaption>Figure 2: Three types of motors, from left to right: (a) EV3 Medium Motor, (b) EV3 Large Motor, (c) NXT Motor</figcaption>
</figure> 


<h3 id="the-sensors">The sensors <a class="btt" href="#">[top]</a></h3>

<p>While you receive several sensors, there are two that are used the most
in the course: the ultrasonic and color sensors. The ultrasonic sensor
(Fig. 3a) is used to measure distance by sending
ultrasonic waves and measuring how long it takes the wave to echo back.
Its main use is in detecting obstacles the robot needs to avoid.
Unfortunately, ultrasonic waves are not the best way to measure distance
and the sensor can easily fail to detect objects or detect objects that
aren’t there, which you will need to try and compensate for in software.
The color sensor (Fig. 3b), often referred to as a light sensor, can
determine the color of an object as well as the intensity of light
reflected by said object. This is useful for detecting the black lines
on the wooden panels your robots will drive on. In order to work
properly, the sensor needs to be placed at a very specific distance from
the object, which you will to determine. Other than that, it is much
more reliable than the ultrasonic sensor. All sensors connect to the
ports labelled 1 - 4 on the bottom of the brick.</p>

<figure>
<img style="width:30%" src="files/sensor-ultrasonic.png">
<img style="width:30%" src="files/sensor-color.png">
<br>
<figcaption>Figure 3: Useful sensors, from left to right: (a) Ultrasonic Sensor, (b) Color Sensor </figcaption>
</figure> 



<h3 id="the-brick">The “Brick” <a class="btt" href="#">[top]</a></h3>

<p>The “Brick” you receive, shown in Fig. 4, is an embedded system as described in the
<a href="#background">background</a> section. Its relevant features are as follows:</p>

<figure>
<img style="width:40%" src="files/ev3.png"><br>
<figcaption>Figure 4: The LEGO “brick”. </figcaption>
</figure> 

<ul>
  <li>
    <p><strong>Speaker</strong>: Can make beeps, useful in some labs to let you know
what your code is doing. Also capable of playing the <em>Imperial
March</em> from Star Wars.</p>
  </li>
  <li>
    <p><strong>Ports A-D</strong>: Used for connecting motors.</p>
  </li>
  <li>
    <p><strong>Ports 1-4</strong>: Used for the various sensors.</p>
  </li>
</ul>


<h2 id="lejos">Software - WeBots and simlejos<a class="btt" href="#">[top]</a></h2>
<hr>

<h3 id="preparing-your-computer">Preparing your computer <a class="btt" href="#">[top]</a></h3>

<p>In order to work with the simulated robot, you need to set up your development
environment as follows.</p>

<ol>
  <li> Install a <a href="https://www.oracle.com/java/technologies/javase-downloads.html"><b>Java Development Kit
    (JDK)</b></a> if needed. As the robot controllers will be developed in Java, the JDK is required to
    compile the code. You must use a 64-bit version of the JDK, version 11 or higher. OpenJDK works too.
  </li><br> <!--As required by the simlejos JAR-->

  <li> Install <a href="https://www.leocad.org/"><b>LeoCad</b></a>, a computer aided design software
    used to build virtual LEGO assemblies which will be used to design the physical appearance of your robots.

    <p>If you are using macOS or Windows, use the link above. If you are using Linux, depending on your distribution,
    LeoCAD might also be available through your package manager. Some Linux distributions (ie, debian) package the
    parts library for LeoCAD separately as "ldraw-parts".</p>
  </li>

  <li> Install <a href="https://cyberbotics.com/"><b>Webots</b></a>, a robot simulation framework that we will use
    to work with virtual robots.

    <p>For macOS or Windows, use the link above. On Windows, select “Install for me only,” not for all users. 
      The Linux version of Webots only needs to be extracted and the executable is in the main folder,
      no installation required. <strong>Keep track of where you installed Webots.</strong></p>
    
    <p><emph>Please note that a lot of the complexity of Webots is abstracted away with the proto files that we provide,
      but feel free to look at the implementation of the proto files or create your own.  We cover here the minimum
      amount of information needed to complete the course, but Webots is a fun tool to play with.</emph></p>
  </li>
  <li>
    <p>Install and setup Eclipse <strong>exactly</strong> as described here.</p>

    <p><strong>Note:</strong> Many students have asked if they could use a previous Eclipse installation. The answer is <strong>no</strong>,
      because we do not want you to have Eclipse settings from a previous course/project. 
      We also do not want our custom settings from step (c) below to interfere with your other courses/projects.</p>

    <p>a) Follow <a href="https://www.eclipse.org/downloads/packages/installer">these instructions</a>. The
installer will ask you what version to install. “Eclipse IDE for
Java EE (Enterprise) Developers” is sufficient for this course.</p>

    <p>b) When starting Eclipse for the first time, select (or create) a workspace folder that is dedicated for this course,
so your other projects can have their own settings.</p>

    <p>c) Configure Eclipse settings according to our requirements. Open Eclipse Preferences 
and select Import (the button in the lower-left corner of the window with this arrow ↘), then choose 
<a href="files/ecse211-eclipse-preferences.epf"><code>ecse211-eclipse-preferences.epf</code></a>. Select all the boxes.</p>

    <p>d) <strong>Strongly recommended:</strong> Use the Eclipse dark theme to better distinguish source code elements (eg, variables, methods).
If it is not already set, open Eclipse Preferences and select <code>General</code> (double-click) <code>→ Appearance → Theme → Dark → Apply and Close</code>.
Restart Eclipse to fully apply the dark theme.</p>

    <!-- TODO add internal link for checkstyle and spotbugs (generate with Jekyll) -->
    <p>e) Add CheckStyle and SpotBugs to Eclipse following <a href="https://mcgill-dpm.github.io/website/EclipseCheckstyleSpotbugs">these
      instructions</a>. These tools help you write better code.</p>

    <strong>Come back to these last two steps once you have opened controller code in Eclipse.</strong>

    <p>f) Set the correct build path for the Webots Controller jar file if needed (if the project has errors shown by
    ❌ or ❗). To do that, right click the project and select
    <code>Properties → Java Build Path → Controller.jar → Edit</code>, and find the file. It is under your webots
    folder, in <code>lib/controller/java</code>.</p>
    
    The default path on many Linux distributions is <code>/usr/local/webots/lib/controller/java</code>.<br>
    The default path on Windows is <code>C:\Users\USERNAME\AppData\Local\Programs\Webots\lib\controller\java</code>.<br><br>

    <figure>
      <img style="width:70%" src="files/build_path.png"><br>
      <figcaption>Figure 6: Eclipse project Java build path</figcaption>
    </figure> 

    <p>g) Add the Webots Java source code to Eclipse. Go to <code>webots/resources/languages/java</code>. Create
    the following nested directory structure there: <code>com/cyberbotics/webots/controller</code>, ie, create a
    <code>com</code> folder, with a <code>cyberbotics</code> folder inside it, and so on. Copy the content of
    <code>SWIG_generated_files</code> to the <code>controller</code> folder you just made (see below).</p>

    <figure>
      <img style="width:70%" src="files/webots_source_folder_structure.png"><br>
      <figcaption>Figure 7: Webots Java source code structure</figcaption>
    </figure>

    <p>Now in Eclipse, open a java source file and enter this code in a method (you can delete this line later):
      <pre>    com.cyberbotics.webots.controller.Accelerometer a;</pre>

    The code should compile (ie, no red underline), if not, make sure you have performed step (4f) correctly.
    Right-click <code>Accelerometer</code> and select <code>Open declaration</code>, or use the shortcut
    (F3 or Ctrl-Click). Then select <code>Attach source</code>, and find the 
    <code>webots/resources/languages/java</code> folder from before. You should now see the source code of
    the Webots <code>Accelerometer</code> class.
    </p>
  </li>
</ol>



<h4>Graphics Note:</h4>
<p>If your hardware is limited, you can improve the performance by adjusting the graphics settings as shown below.
  In addition, if you experience low framerates on macOS, go to <code>Tools → Preferences → OpenGL</code> and disable Ambiant Occlusion.</p>

  <figure>
    <a href="files/Webots_graphics_settings.png"><img style="width:50%" src="files/Webots_graphics_settings.png"></a><br>
    <figcaption>Figure 9: Webots graphics settings</figcaption>
  </figure>
  
<h3 id="webots_overview">Webots Overview <a class="btt" href="#">[top]</a></h3>
<p>Before we start simulating our own robots, let's look at how Webots works and how to use it.  To do so, we will use one of the example files provided with Webots.</p>

<p>Start Webots, and open the sample by going <code>File → Open Sample World...</code>, then navigate through the list to find <code>samples → devices → bumper</code>.  Once loaded, your window should look similar to the screenshot in Figure 10.  We will now describe the purpose of the main panels and menus of the Webots environment.</p>

<figure>
<a href="files/webots-mainwindow.png"><img style="width:80%" src="files/webots-mainwindow.png"></a><br>
<figcaption>Figure 10: Webots main window</figcaption>
</figure> 

<h4>Toolbar</h4>
<p>At the top of the screen is the main toolbar which contains icons for commonly used functions.  Some of those icons should be </p>
<ul>
 <li><img src="files/webots-icon-hide.png">: Hide or show the scene tree.</li>
 <li><img src="files/webots-icon-plus.png">: Add nodes to the scene tree.</li>
 <li><img src="files/webots-icon-resetview.png">: Reset the viewpoint.</li>
 <li><img src="files/webots-icon-reload.png">: Reload the simulation</li>
 <li><img src="files/webots-icon-play.png">: Start the simulation, will turn into a pause icon to pause the simulation and vice-versa.  You can click this button if the simulation is not already running to start the simulation and see the robot move.</li>
</ul>
<p>It is strongly suggested not to use the fast-forward buttons as it can cause the simulation to fail.</p>


<h4>3D View</h4>
<p>The 3D view is the main part of the window and is where you see the robot and its environment.  You can change the position of the camera (move around) with the following default controls:</p>

<ul>
 <li>Pan: Right click and drag</li>
 <li>Tilt: Left click and drag</li>
 <li>Zoom: Scroll-wheel</li>
</ul>

<h4>Console</h4>
At the bottom of the window is the console.  Both Webots and your controller can print information here, ie, when you use <code>System.out.println(...)</code>, it will be printed to this console.

<h4>Text Editor</h4>
On the right side of the window is the text editor, where it is possible to write programs. It is useful to maximize, or un-dock
this panel when writing code to get more screen space. The text editor is useful if you just want to change something minor in the code,
like a constant, without switching to Eclipse.

<h4>Scene Tree</h4>
<p>The panel in the left column is the "Scene Tree", where the world and all objects within it are defined. Each element in the list is a node, which can be expanded by double-clicking on it, or using the small arrow beside it.  Expanding a node will present the parameters of the node and possibly children nodes.</p>

<p>The first two elements of the scene tree are always the <code>WorldInfo</code> and the <code>Viewpoint</code>.  These cannot be removed from the tree.  The <code>WorldInfo</code> contains global parameters that affect everything in the world, ie, gravity.  The <code>Viewpoint</code> node controls the parameters of the virtual camera that lets you see the simulation in the "3D View" panel.</p>

<p>All of the other nodes define the contents of the virtual world.  Their order is not strictly important, <small>unless references are used between objects, in which case the node being referenced needs to appear before the node containing the reference</small>.  Looking at the sample, the next two nodes are the <code>TexturedBackground</code> and the <code>TexturedBackgroundLight</code> nodes.  These two nodes work together to create a "sky box" around our world and create some general lighting.  Without these two nodes, the image would be black.</p>

<p>The next node is the <code>RectangleArena</code>.  This is a proto node, that is, this node is a self-contained mini scene tree that contains other objects.  The <code>RectangleArena</code> creates the floor and the walls, but instead of defining the parameters of each object separately, the proto node has simple parameters such as <code>floorSize</code> and <code>floorTileSize</code> that control the underlying objects.</p>

<p>The next four nodes are the four colored solid boxes within the arena.  These are solid nodes.  Solid nodes are a base type of nodes that define solid objects.  Expanding one of these nodes presents its parameters.  The important ones here are:</p>

<ul>
 <li><code>translation:</code> the position of the solid in the world, in Cartesian coordinates.</li>
 <li><code>rotation:</code> the rotation of the solid in the world.  The notation here is similar to quaternion notation, where he rotation is defined as an angle in radian and an axis.  For example, setting x=1, y=0, z=0, and angle=1.57 means a 90 degrees rotation around the x axis.  This might seem a little unintuitive at first, but it's a common and useful notation for 3D geometry.</li>
 <li><code>children:</code> this parameter is a subtree that can contain one or more nodes.  In the case of the boxes in the sample, it contains only one children node of type <code>shape</code>.  A shape node is a 3D model that has both a geometry and an appearance component.  Webots has different base solids predefined for the geometry, such as the <code>box</code> used in the sample.</li>
 <li><code>boundingObject:</code> The bounding object defines the shape used by the simulator for the collision detection.  It contains a single sub-node of type <code>shape</code>.  In the case of the sample file, a reference to the shape node that defines the appearance of the box is used for the bounding box as both are the same.  However, in most cases, the bounding box contains a simplified model of the object as complex geometry can cause issues or slow down the simulator.</li>
 <li><code>physics:</code> the physics parameter can hold a <code>physics</code> node, which defines the mass, center of mass, and other parameters of the solid.  In the case of the obstacle blocks in the sample file, the physics parameter is set to NULL, so the simulator will not simulate these objects (they are stationary).</li>
</ul>

<p>The last node is of type <code>Robot</code>.  This is a node similar to the <code>solid</code> node, but has more parameters, most notably, the <code>controller</code> parameter which allows you to choose the the program that will control the robot.  You can explore the children of the robot node to see more type of nodes available in Webots, including the <code>transform</code> and <code>hingeJoint</code> nodes.  We will discuss these types of nodes in more details when we design our robot.</p>

<h4>Project Folder Structure</h4>
<p>There are two project folders in Webots.  The first is the "system" project directory, which resides in the Webots installation directory.  The second is the "local" project folder, where your files reside.  Both folders have the same structure and contain at a minimum the following subfolders:</p>
<ul>
<li><strong>controllers: </strong> contains the robot controller programs, each in their respective subfolder.</li>
<li><strong>protos: </strong> contains proto files (.proto).  These files are sub-trees that can be inserted into the world scene tree as a single node.</li>
<li><strong>worlds: </strong> contains world definition files (.wbt), which are the textual definition of the scene tree.</li>
</ul>
<p>Your "local" project folder can be placed anywhere on your computer.  You should only use the "local" project folder, as changing the system files can cause unstability.</p>

<hr>
<h3 id="webots_designingARobot">Designing a Robot <a class="btt" href="#">[top]</a></h3>
For all work related to this course, we ask that you use the supplied lab projects files to make sure you have all of
the required parts in Webots as well as all of the wrapper classes to simulate the LEGO components.  You can unzip
the provided project files anywhere as long as it's not within the WeBots installation folder.  Once the project
folder is extracted, opening the world file (.wbt) located in the <code>worlds</code> subfolder in WeBots will open
the project.  WeBots automatically looks to find the <code>protos</code> and <code>controllers</code> subfolders in
the parent folder of the world file.

<h4>Modeling the robot</h4>
<p>The first step in simulating a robot is to prepare its digital model. To do so, open LeoCAD and you will get a
  window similar to the screenshot shown in Figure 11. <strong>The steps below show what you need to build for Lab 1.
  For Lab 0, you can build a simpler robot by adapting these steps to make a robot that has a fixed touch sensor
  pointing forward, instead of a rotating ultrasonic sensor.
  </strong></p>

<figure>
<a href="files/leocad-main.png"><img style="width:70%" src="files/leocad-main.png"></a><br>
<figcaption>Figure 11: The main LeoCAD window.</figcaption>
</figure> 

There are 5 main panels in LeoCAD, the first is a 3D rendering of your model.  You can interact with this view using the following default controls:

<ul>
 <li>Pan: Right click and drag while holding the shift key</li>
 <li>Tilt: Right click and drag</li>
 <li>Zoom: Scroll-wheel</li>
</ul>

The other 4 panels are:
<ul>
 <li>Parts: This allows you to select a parts list and select individual parts.  You can drag parts to the 3D view to add them to your model.</li>
 <li>Colors: This is where you select the color of a part, before adding it to your model.  The color can be changed after being placed by editing the part properties.</li>
 <li>Properties: The properties tab provides control over the parameters of the selected part.  This is useful to adjust the position of a part more precisely than moving it in the 3D world with the mouse.</li>
 <li>Timeline: This is used to create stop motion animations, we will not need this.</li>
</ul>

<p>It is now time to design a robot by selecting the parts and dragging them to our model.  Note: for the purpose of
  simulation, it is not required or desired to add every single peg between parts.  Adding these increases the number
  of triangles that will need to be rendered by the simulator and can slow down the overall simulator, depending on
  your system.  Note: the wheels that come with kit, and those you should use, are called <strong>"Wheel Rim 20 x 30,
  6 Spokes, Ribs with Tyre 43.2 x 26 Balloon Small"</strong> in LeoCAD.  These wheels have a radius of exactly 21.465 cm.
  The part defined in the simulator is defined with a value of 21 cm to both keep use a simple round number and to
  simulate the tires deforming a little bit under the weight of the robot 😉.</p>

<p>Once you are done designing your robot, you should have a complete 3D model of your robot.  An example design is
  given <a href="files/robot.ldr">here</a> and shown in Figure 12.</p>

<figure>
<a href="files/leocad-sample.png"><img style="width:70%" src="files/leocad-sample.png"></a><br>
<figcaption>Figure 12: Sample robot.</figcaption>
</figure> 

<p>At this point, this design is a static 3D model.  It contains no information about which parts are motors or what
  their rotation axes are. Similarly, the sensors are nothing more than empty shells.  To use this 3D model in the
  simulator and have the parts behave as they should, we need to split the model into its component sub-assemblies.
  Anything connected to the main controller is the base assembly, and anything connected to the rotating part of a
  motor is a sub-assembly.  Each of these assemblies will need to be exported individually from LeoCAD.</p>

<p>To export a sub-assembly of a robot, it is recommended to start with the whole robot and create a new ldr file
  (<code>File → Save As</code>) for the sub-assembly.  Doing this keeps the original file with the whole robot intact.
  In the newly created ldr file, we can now remove parts that are not in the sub-assembly so that we are left with the
  desired parts.</p>

<p>For the robot shown in Figure 11, the main assembly is shown in Figure 13.  The wheels were removed as they rotate
  around the axis of the bottom motors, the ultrasonic sensor and its few mounting parts are also removed because they
  rotate on the top motor <strong>(which is not needed for Lab 0)</strong>.
  Not visible in Figure 13 is that the ball caster in the back of the  robot has also been
  removed as the ball is itself a sub-assembly as it needs to rotate, more on this later.</p>

<figure>
<a href="files/leocad-mainassembly.png"><img style="width:70%" src="files/leocad-mainassembly.png"></a><br>
<figcaption>Figure 13: Sample robot main assembly.</figcaption>
</figure> 

<p>The other two sub-assemblies are shown in Figure 14.</p>

<figure>
<a href="files/leocad-sensorassembly.png"><img style="width:40%" src="files/leocad-sensorassembly.png"></a>
<a href="files/leocad-wheelassembly.png"><img style="width:40%" src="files/leocad-wheelassembly.png"></a><br>
<figcaption>Figure 14: Sample robot sub assemblies.</figcaption>
</figure> 

<p>For simplicity, we provide you with some of the parts predefined in the simulator.  The following parts have been defined for convenience:</p>

<ul>
 <li>Controller: The EV3 controller</li>
 <li>Motors: All three types of motors (NXT, Large EV3, and Medium EV3)</li>
 <li>Sensors: The Ultrasonic and Color Sensors</li>
 <li>Wheels: The wheels that come with kit, the ball-caster, and the old caster are defined.</li>
</ul>

<p>For this reason, these parts can be removed from the assemblies and we end up with two models that need to be exported from LeoCAD.
  Figure 15 shows what these two look like for the sample robot presented in Figure 11.
  <strong>For Lab 0, you will only need to export one assembly, which will closely resemble the one on the left.</strong></p>

<figure>
<a href="files/leocad-mainassembly-export.png"><img style="width:55%" src="files/leocad-mainassembly-export.png"></a>
<a href="files/leocad-sensorassembly-export.png"><img style="width:35%" src="files/leocad-sensorassembly-export.png"></a><br>
<figcaption>Figure 15: Sub-assemblies that need to be exported from LeoCAD for the sample robot.</figcaption>
</figure> 

<p>Save all of the sub-assemblies as separate <code>.ldr</code> files as you will need to convert them to the format used by the simulator in the next part.  The sample robot is pretty basic, so it only has 2 sub-assemblies, but larger and more complicated robots might have more moving parts.  For convenience, here are the two sub-assembly files for the sample robot:</p>

<ul>
 <li><a href="files/robot-base.ldr">Base Assembly</a></li>
 <li><a href="files/robot-ultrasonicsensormount.ldr">Sensor Assembly</a></li>
</ul>

<h4>Converting the LeoCAD files for Webots</h4>
<p>As mentioned previously, LeoCAD only provides the visual appearance of the robot.  To simulate the robot, Webots needs more information about the parts.  It needs the bounding box to detect and handle collisions, the mass of the parts to compute acceleration, and it needs the physical appearance model, including the 3D model and the colors, to make everything look nice.  To convert the files and add some of that missing information, we provide you with a converter, available <a href="converter.html">here</a>.  On this page, you will be able to upload a <code>.ldr</code> file and obtain the converted files.  You will receive 3 files, packaged within a zip file.  Uploading a file called <code>filename.ldr</code>, you will receive a zip file called <code>filename.zip</code> containing the following three <code>.proto</code> files:

<ul>
 <li><code>filename-boundingbox.proto</code>: This contains a Box node of a size that contains your model.  We can use this as the bounding box for the simulator.</li>
 <li><code>filename-shape.proto</code>: This contains the Shape of your model 3D model with the appearance information.</li>
 <li><code>filename-solid.proto</code>: This contains a solid node that ties uses the shape, the bounding box, and adds mass information.  This is the file you will use most often in the simulator.  <emph>Note: the mass is an approximation based on the volume of your model and the density of the plastic used to make LEGO.</emph></li>
</ul>

<p>You should place those 3 <code>.proto</code> files in the <code>protos</code> sub-folder of your project folder.  Note: You can create sub-folders in the <code>protos</code> folder to help classifying parts.</p>

<p>When adding proto files to your project, make sure to click <img src="files/webots-icon-reload.png"> so that webots can reload the new files or new versions of the files.</p>

<p>More information is available on the <a href="converter.html">converter page</a>.</p>


<h4>Defining the robot in the simulator</h4>

<p>Before defining the robot, open one of the provided world files. For this example, we will use the world file from
  the first lab. Figure 16 shows what the world looks like. <strong>The Lab 0 world is very similar, but has a smaller
  playing field and no blocks.</strong></p>

<figure>
<a href="files/webots-samplerobot1.png"><img style="width:75%" src="files/webots-samplerobot1.png"></a>
<figcaption>Figure 16: Lab 1 world file after being opened.</figcaption>
</figure> 

<p>The first step is to click the <img src="files/webots-icon-plus.png"> button to add a new node to the scene tree.  From the "Add a node" selection dialog, select <code>PROTO nodes → DPM → DPM-Robot</code> node type.  This will create the robot node, and you should see a coordinate system marker appear at the origin of the world, as shown in Figure 17.  You'll also see in the console that webots has started the "void" controller.  This is the default controller that does nothing.</p>

<figure>
<a href="files/webots-samplerobot2.png"><img style="width:75%" src="files/webots-samplerobot2.png"></a>
<figcaption>Figure 16: New robot node created.</figcaption>
</figure> 

<p>Now, expand the robot node and set the position so that the robot is somewhere above the arena.  Click on the children node and click the <img src="files/webots-icon-plus.png"> button to add a new sub-node.  Select <code>PROTO nodes (Current Project) → Mindstorm → EV3 (solid)</code> to insert an EV3 controller into the robot.  You should end up with something that looks like Figure 17.</p>

<figure>
<a href="files/webots-samplerobot3.png"><img style="width:75%" src="files/webots-samplerobot3.png"></a>
<figcaption>Figure 17: Robot position adjusted and an EV3 controller is added.</figcaption>
</figure> 

<p>The EV3 is not in the right orientation, to correct this, we can expand the EV3 node and set its rotation to "1 0 0 -1.57", a rotation of -90 degrees around the x axis.  This is something that will need to be done for most parts that are converted from LeoCAD as it uses a different coordinate system.  Figure 18 shows what you should now see.</p>

<figure>
<a href="files/webots-samplerobot4.png"><img style="width:75%" src="files/webots-samplerobot4.png"></a>
<figcaption>Figure 18: Rotation of the EV3 controller is corrected.</figcaption>
</figure> 

<p>We can now click on the children node of the robot and once again click the <img src="files/webots-icon-plus.png"> button.  This time we will add the base assembly of our robot by selecting <code>PROTO nodes (Current Project) → Robot → robot-base-solid (Solid)</code>. The name of the proto will not be the same, it will be the name of the ldr file you converted earlier, with the suffix "-solid".  As we did before, we need to set the rotation of the newly imported node to "1 0 0 -1.57". Figure 19 shows what you should now see.</p>

<figure>
<a href="files/webots-samplerobot6.png"><img style="width:75%" src="files/webots-samplerobot6.png"></a>
<figcaption>Figure 19: Addition of the base assembly.</figcaption>
</figure> 

<p>With the rotation fixed, we see that the part is still not in the correct location.  This is because each converted part from Leocad is re-centered around its centroid.  To fix this we can edit the position attribute of the node.  For the sample robot, the translation needs to be (0,-0.014,-0.008).  The simplest way to move the parts to the correct positions and orientations is to select the node, a coordinate system with arrows on and around each axis should appear.  These arrows can be used to roughly move and rotate the part.  To get a more accurate position, click in the value box of one component (highlighted in Figure 20), type 0.001 and use the up and down arrow keys to move the parts by 0.001m (1mm) manually.  The arrow keys will change the last digit of the value by 1, so if you type 0.0001, each arrow key stroke would move the part by 0.1mm.</p>

<figure>
<a href="files/webots-samplerobot7.png"><img style="width:75%" src="files/webots-samplerobot7.png"></a>
<figcaption>Figure 20: Setting the position of the main assembly.</figcaption>
</figure> 

<p>We now want to add the motors. Once again, click on the children node of the robot and click the
  <img src="files/webots-icon-plus.png"> button.  This time we will select <code>PROTO nodes (Current Project) →
  Mindstorm → EV3-LargeMotor (Solid)</code> for the EV3 large motors and <code>PROTO nodes (Current Project) →
  Mindstorm → NXT-Motor (Solid)</code> for the NXT motor <strong>(the latter is not needed for Lab 0)</strong>.
  As before, we will set the rotation and position so that
  each motor is in the correct location and orientation. One important parameter of the motors is the "name". Each
  motor needs a different name as this is the name you will use in your controller to distinguish between the motors.
  <b>Motors need to be called "A", "B", "C", or "D"</b> to match the port where they are connected on the the EV3
  brick. We can also add the color sensor to the robot at this point by adding a <code>PROTO nodes (Current Project)
  → Mindstorm → EV3-ColorSensor (Solid)</code> node. <strong>For Lab 0, add the touch sensor instead.</strong>
  We can also add the ball caster at the back of the robot by
  inserting a <code>PROTO nodes (Current Project) → Mindstorm → BallCaster (Transform)</code> node and positioning
  it appropriately. Each sensor also needs a unique name. <b>Sensors need to be called "S1", "S2", "S3", or
  "S4"</b> to match the port where they are connected on the the EV3 brick.  You should now have something like
  Figure 21.</p>

<figure>
<a href="files/webots-samplerobot9.png"><img style="width:75%" src="files/webots-samplerobot9.png"></a>
<figcaption>Figure 21: Adding the three motors and the color sensor.</figcaption>
</figure> 

<p>We can now add the parts that are attached to the motors.  We will start with the left wheel.  To do so, select and expand the motor node that corresponds to the left motor.  You'll see within the motor node that there is a children node.  Select this children node and click the <img src="files/webots-icon-plus.png"> button.  Select <code>PROTO nodes (Current Project) → Mindstorm → wheel (Solid)</code> node.  As you can see in Figure 22, the wheel is added at the end position of the motor, rather than at the center of the robot.  This is because the proto node applies the translation corresponding to the position of the shaft to its children nodes.</p>

<figure>
<a href="files/webots-samplerobot10.png"><img style="width:75%" src="files/webots-samplerobot10.png"></a>
<figcaption>Figure 22: Adding the left wheel.</figcaption>
</figure> 

<p>As before, we can adjust the position and orientation of the wheel.  We can select the children node of the right motor and do the same thing to add the right wheel.  We can also do the same to add the mount for the ultrasonic sensor.</p>

<figure>
<a href="files/webots-samplerobot11.png"><img style="width:75%" src="files/webots-samplerobot11.png"></a>
<figcaption>Figure 23: Adding the right wheel and the ultrasonic mount.</figcaption>
</figure> 

<p><strong>If you are doing Lab 0, skip this step.</strong> The last thing to do is to add the ultrasonic sensor
  itself. Select the children node of the NXT motor and add a new node of type <code>PROTO nodes (Current Project) →
  Mindstorm → EV3-Ultrasonic (Solid)</code>, and adjust its position. We are almost done building the robot.</p>

<figure>
<a href="files/webots-samplerobot12.png"><img style="width:75%" src="files/webots-samplerobot12.png"></a>
<figcaption>Figure 24: Final robot assembly.</figcaption>
</figure> 

<p><!-- The final step is to go back to the root of the robot node and select the physics parameter.  Click the <img src="files/webots-icon-plus.png"> button and select <code>Base nodes → Physics</code> expand it and set the mass to 1 and the density to -1.  The actual mass of the robot is the sum of the masses of its components, but it is preferable to not set the robot mass to 0 as it sometimes causes issues.  Do not set any boundingObject for the robot node itself as the individual bounding boxes of the component parts create the bounding object of the robot.  Finally, in the <code>physics</code> node, double click the <code>inertiaMatrix</code> property and insert an identity matrix, so that the mass of the robot is centered at its origin. to  -->At this point the robot is complete and ready to be simulated. Click the <img src="files/webots-icon-play.png"> button and you should see your robot fall down to the floor.  Congratulation, it's a robot 🤖.  <strong>Note that this robot is only provided as an example, it will not work for all labs.</strong>  Hint: you might not want the color sensor on the rotation axis 😉.</p>

<p>Selecting the robot node will show the bounding volume of the robot as a set of wire frame box around it.  As you can see, the bounding volume is a simplified approximation of the robot's shape, which is the union of all the bounding boxes of the robot's components.  The only parts that are more precisely modeled in the bounding volume are the wheels and the ball caster as those parts need to be more accurately simulated.</p>

<figure>
<a href="files/webots-samplerobot13.png"><img style="width:75%" src="files/webots-samplerobot13.png"></a>
<figcaption>Figure 25: Bounding volume of the sample robot.</figcaption>
</figure>


<h3>Transferring your robot</h3>

There is no easy way to move your robot from one lab to another from the graphical user interface.  Redefining the robot in each lab is a cumbersome, but functional solution.  If you want to directly transfer your robot to another lab, you should do the following:
<ol>
 <li>Right click the robot node and select <code>Export</code>.  Export the node to a <code>.wbo</code> file.</li>
 <li>Export the node to a <code>.wbo</code> file.</li>
 <li>Open the <code>.wbo</code> file and copy it's content.</li>
 <li>Navigate to the <code>worlds</code> sub-folder of the project folder and open the <code>.wbt</code> corresponding to the world where you want to insert your robot.</li>
 <li>Paste the content from the <code>.wbo</code> file at the end of the <code>.wbt</code> file.</li>
 <li>Load (or reload) the world in WeBots and your robot should be in the new file.</li>
</ol>
<hr>


<h3 id="webots_writingacontroller">Writing a controller <a class="btt" href="#">[top]</a></h3>

<p>For the first few labs, you will be provided with skeleton code, so you will not need to create a controller from scratch.  A set of examples (<a href="files/examples.zip">examples.zip</a>) on how to use each of the simulated devices is provided.  These examples, the skeleton code, as well as the examples presented in class should provide a good overview of how controllers are written.</p>

<p>To select which controller your robot should use, expand your robot node in the world scene tree and select the
  controller node. In the selection pane, you can select a controller and click the Edit button to open the Webots
  built-in editor (See Fig. 10). Once the controller is selected, it can compiled by clicking <code>Build →
  Clean</code>, then <code>Build → Build</code> in the main menu bar.</p>

<p>When you want to compile a new version of a controller, it is recommended to reload and rebuild everything as some modifications may not be recompiled properly and some Webots object may not be linked properly otherwise.  To do so, start by saving your world with and reloading it with <img src="files/webots-icon-reload.png">, then click <code>Build → Clean</code>, then <code>Build → Build</code> to rebuild the entire controller and reset the world.  <b>If you notice strange behaviors such as sensors not returning measurements, recompiling and resetting the world a second time usually fixes things.</b></p>

<p>You can use either the basic built-in text editor provided by WeBots, Eclipse, or any other editor of your
choice (eg, VS Code). However, to prevent issues, it is recommended to build the code from within Webots as it
links the code to the webots classes and resets the simulator properly. The starter code we provide for the Labs,
including Lab 0, contain predefined projects for your convenience (see step 4 above for how to set up Eclipse).
To open a lab in Eclipse, import it as an Eclipse project from archive using the <code>File → Import</code> menu.
</p>

<!--  In the case of a compilation error, the file and line where the error occurs is printed to the Webots console. -->
<h4>Device naming</h4>
<p>For your controller to work, the name of the devices (motors/sensors) defined on your robot need to match the name expected by the controller looks for when being initialized.  For controller code to be more similar to what would be written for a physical LEGO robot, Motors need to be called "A", "B", "C", or "D" and sensors need to be called "S1", "S2", "S3", or "S4" to match the port where they are connected on the the EV3 brick.  The name of the devices on the robot are set by changing the name parameter of the various device nodes in the world scene tree.  The port that the controller uses are defined in the <code>resources.java</code> file in the files provided for labs 1 and 2.  If the names do not match, the controller will crash with an exception.</p>


<h4>Threading</h4>
<p>Special consideration needs to be given to threading as time in the simulator works differently than in real life.  The simulator computes the state of the world in discrete time steps, whereas real time is continuous.  <b>The main issue caused by this is that calls to <code>Thread.sleep()</code> do not behave as they normally would, and should be avoided</b>.  To deal with this difference, we need to make sure threads are synchronized properly.  To do so, we have defined an <code>executionController</code> to control execution between threads.  The main thread should runs the simulation steps by calling <code>executionController.performPhysicsStep();</code>.  Other threads should call <code>executionController.waitUntilNextStep();</code> to pause execution until the next physics step has been computed, or <code>executionController.sleepFor(long millis);</code> to "sleep" for a given number of milliseconds.</p>



<p><b>IMPORTANT:</b> For this synchronization to work, the <code>executionController</code> relies on a <code>CyclicBarrier</code>.  The major downside of using a <code>CyclicBarrier</code> is that the number of threads needs to be known and explicitly defined.  To set the number of parties for the <code>CyclicBarrier</code>, you need to call <code>executionController.setNumberOfParties(numberOfParties);</code>.  In the provided code for labs 1 and 2, this is done in the <code>main.java</code> file.  The number of parties should match the number of threads.  By default, when the program starts, a single party is defined, but you will need to adjust the number when starting or ending threads by calling <code>executionController.setNumberOfParties(numberOfParties);</code>.</p>

<h3>Notable changes between the Lejos API and the simulated Lejos API</h3>

<h4>Sounds</h4>
<p>Due to the differences between how Webots and LeJOS handle sound, not all LeJOS functions have been implemented in the wrapper.  The following three functions are implemented:</p>

<ul>
<li><code>LocalEV3.getAudio().beep();</code> This is equivalent to the LeJos function <code>Sound.beep();</code></li>
<li><code>LocalEV3.getAudio().playSample(String filename);</code> This is equivalent to the LeJos function <code>Sound.playSample(java.io.File file)</code> but with a filename as an argument instead of a <code>java.io.File</code>.  The files should be in wav format as other formats may not work on all platforms, and should be placed in your controller folder.</li>
<li><code>LocalEV3.getAudio().speak(String text);</code> This has no LeJOS equivalent.  This uses text to speech to convert a string into voice and plays the resulting sound.</li>
</ul>

<p>Examples of the usage of these three functions is provided in the <a href="files/examples.zip">example files</a>.</p>


<h4>Ultrasonic Sensor</h4>
<p>The simulated ultrasonic sensor does not have a "listen" mode as the simulator does not support this.</p>



<h3>Porting Code</h3>
We will now take a look at a simple example to show the basic difference between writing controller code for a real EV3
brick and writing code for a simulated brick. The following controller, from the lecture notes, has the robot drive in
a straight line until the touch sensor detects an obstacle. The differences between the two programs are highlighted in
green. Please note that for brevity, this code does not follow all conventions you are expected to follow in this
course, eg, using Javadoc.<br><br>


 <table style="width:100%">
  <tr>
    <th><b>Physical Robot</b></th>
    <th><b>Webots</b></th>
  </tr>
  <tr>
    <td style="vertical-align:top"><pre>
package ca.mcgill.ecse211.project;


import lejos.hardware.motor.Motor;
import lejos.hardware.port.SensorPort;
import lejos.hardware.sensor.EV3TouchSensor;
import lejos.robotics.RegulatedMotor;
import lejos.robotics.SampleProvider; 

public class Demo1 {

  static final int FWDSPEED = 300; // deg/s

  static final RegulatedMotor leftMotor = Motor.A; 
  static final RegulatedMotor rightMotor = Motor.D; 

  static SampleProvider touchSensor = new EV3TouchSensor(SensorPort.S2).getTouchMode();
  static float[] touchSensorSample = new float[touchSensor.sampleSize()]; 

  public static void main(String args[]) { 

    

    leftMotor.setSpeed(FWDSPEED);
    rightMotor.setSpeed(FWDSPEED);
    leftMotor.forward();
    rightMotor.forward();
    
    while (touchSensorSample[0] != 1) {
      <mark style="background-color:#f6f1bf;">/* In both lejos and simlejos, update touchSensorSample by fetching a sample from</mark>
      <mark style="background-color:#f6f1bf;"> * the touch sensor provider and storing in touchSensorSample at index 0.</mark>
      <mark style="background-color:#f6f1bf;"> * </mark>
      <mark style="background-color:#f6f1bf;"> * Equivalent pseudocode: touchSensorSample = touchSensor.fetchSample() */</mark>
      touchSensor.fetchSample(touchSensorSample, 0);
    }
    
    
    
    
    
    

    System.exit(0);
  }
}
    </pre></td>
    <td style="vertical-align:top"><pre>
package ca.mcgill.ecse211.project;

<mark style="background-color:#aee2ae;">import simlejos.ExecutionController;</mark>
import <mark style="background-color:#aee2ae;">simlejos</mark>.hardware.motor.Motor;
import <mark style="background-color:#aee2ae;">simlejos</mark>.hardware.port.SensorPort;
import <mark style="background-color:#aee2ae;">simlejos</mark>.hardware.sensor.EV3TouchSensor;
import <mark style="background-color:#aee2ae;">simlejos</mark>.robotics.RegulatedMotor;
import <mark style="background-color:#aee2ae;">simlejos</mark>.robotics.SampleProvider;

public class Demo1 {

  static final int FWDSPEED = 300; // deg/s

  static final RegulatedMotor leftMotor = Motor.A; 
  static final RegulatedMotor rightMotor = Motor.D; 

  static SampleProvider touchSensor = new EV3TouchSensor(SensorPort.S2).getTouchMode();
  static float[] touchSensorSample = new float[touchSensor.sampleSize()]; 

  public static void main(String[] args) {
    <mark style="background-color:#aee2ae;">// Need to define how many threads are synchronized to simulation steps</mark>
    <mark style="background-color:#aee2ae;">ExecutionController.setNumberOfParties(1);</mark>

    leftMotor.setSpeed(FWDSPEED);
    rightMotor.setSpeed(FWDSPEED);
    leftMotor.forward();
    rightMotor.forward();

    while (touchSensorSample[0] != 1) {
      <mark style="background-color:#aee2ae;">// Need to explicitly perform the physics step</mark>
      <mark style="background-color:#aee2ae;">ExecutionController.performPhysicsStep();</mark>
      

      touchSensor.fetchSample(touchSensorSample, 0);
    }
    
    <mark style="background-color:#aee2ae;">leftMotor.stop();</mark>
    <mark style="background-color:#aee2ae;">rightMotor.stop();</mark>
    
    <mark style="background-color:#aee2ae;">// Need to perform a step for the stop to be registered</mark>
    <mark style="background-color:#aee2ae;">ExecutionController.performPhysicsStep();</mark>
    
    System.exit(0);
  }
}
    </pre>
    </td>
  </tr>
</table> 

The main difference between the two version is the addition of the <code>ExecutionController</code> which allows the controller to interface and synchronize with the simulator.  The other change is the addition of the motor stopping lines at the end.  When a controller exits in the real LeJOS environment, all of the devices are reset.  This is not the case in Webots, so it the motors are running when the controller exits, they will keep running.

<h2 id="submissionInstructions">Submission Instructions <a class="btt" href="#">[top]</a></h2>
Please consult the submissions instructions on MyCourses and for each lab. You do not need to submit Lab 0 as it is not graded.<br><br>

<p style="font-size:0.8em">© Instructor and Teaching Assistant generated course materials (e.g., handouts, notes, summaries, assignments, exam questions, etc.) are protected by law and may not be copied or distributed in any form or in any medium without explicit permission of the instructor. Note that infringements of copyright can be subject to follow up by the University under the Code of Student Conduct and Disciplinary Procedures.</p>
</div>

</body>
</html>


 
